/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Growl
 #	author : miyako
 #	2016/07/22
 #
 # --------------------------------------------------------------------------------*/

#include "4DPluginAPI.h"
#include "4DPlugin.h"

#define CALLBACK_IN_NEW_PROCESS 0
#define CALLBACK_SLEEP_TIME 59

std::mutex globalMutex; /* for notificationTypes,notificationContexts */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */

@interface Listener : NSObject <GrowlApplicationBridgeDelegate>
{

}

- (void) growlNotificationWasClicked:(id)clickContext;
- (void) growlNotificationTimedOut:(id)clickContext;
- (NSString *) applicationNameForGrowl;
- (NSDictionary *) registrationDictionaryForGrowl;
- (void)call:(notification_type_t)type event:(NSString *)context;

@end

namespace Growl
{
	Listener *listener = nil;
	
	//constants
	process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0G\0R\0O\0W\0L\0\0\0";
	process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;
	NSString *defaultNotificationName = @"name";
	NSString *defaultApplicationName = @"4D";
	
	//context management
	std::vector<notification_type_t> notificationTypes;
	std::vector<CUTF16String> notificationContexts;
	
	//callback management
	C_TEXT LISTENER_METHOD;
	process_number_t METHOD_PROCESS_ID = 0;
	bool PROCESS_SHOULD_TERMINATE = false;
    bool PROCESS_SHOULD_RESUME = false;
    
	//dict
	NSArray *defaultNotifications = [NSArray arrayWithObject:defaultNotificationName];
	NSDictionary *regDict = [NSDictionary
		dictionaryWithObjects:
		[NSArray arrayWithObjects:
		defaultApplicationName,
		defaultNotifications,
		defaultNotifications,
		nil]
		forKeys:
		[NSArray arrayWithObjects:
		GROWL_APP_NAME,
		GROWL_NOTIFICATIONS_ALL,
		GROWL_NOTIFICATIONS_DEFAULT,
		nil]];
};

@implementation Listener

- (id)init
{
	if(!(self = [super init])) return self;
	
	[GrowlApplicationBridge setGrowlDelegate:self];

	return self;
}

- (void)dealloc
{
	[[NSUserNotificationCenter defaultUserNotificationCenter]removeAllDeliveredNotifications];

	[super dealloc];
}

- (NSString *) applicationNameForGrowl
{
	return Growl::defaultApplicationName;
}

- (NSDictionary *) registrationDictionaryForGrowl
{
	return Growl::regDict;
}

- (void) growlNotificationWasClicked:(id)clickContext
{
	[self call:NotificationWasClicked event:clickContext];
}

- (void) growlNotificationTimedOut:(id)clickContext
{
	[self call:NotificationTimedOut event:clickContext];
}

- (void)call:(notification_type_t)type event:(NSString *)context
{
	if(Growl::LISTENER_METHOD.getUTF16Length())
	{
		CUTF16String s;
		uint32_t len = [context length];
		uint32_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
		std::vector<uint8_t> buf(size);
		if([context getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
		{
			s = CUTF16String((const PA_Unichar *)&buf[0], len);
		}
		
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex);
            
            Growl::notificationTypes.push_back(type);
            Growl::notificationContexts.push_back(s);
        }
		
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);
            
            Growl::PROCESS_SHOULD_RESUME = true;
        }
	}
}
@end

#pragma mark -

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
	returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
	CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
	NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
	returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

#pragma mark -

void listenerLoop()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        Growl::PROCESS_SHOULD_TERMINATE = false;
    }
    
	if(1)
	{
		Growl::listener = [[Listener alloc]init];
	}

	while(!PA_IsProcessDying())
	{
		PA_YieldAbsolute();
        
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;

        if(1)
        {
            PROCESS_SHOULD_RESUME = Growl::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = Growl::PROCESS_SHOULD_TERMINATE;
        }
        
		if(PROCESS_SHOULD_RESUME)
		{
            size_t TYPES;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                TYPES = Growl::notificationTypes.size();
            }
            
			while(TYPES)
			{
				PA_YieldAbsolute();
				
				if(CALLBACK_IN_NEW_PROCESS)
				{
				 C_TEXT processName;
				 generateUuid(processName);
				 PA_NewProcess((void *)listenerLoopExecuteMethod,
											 Growl::MONITOR_PROCESS_STACK_SIZE,
											 (PA_Unichar *)processName.getUTF16StringPtr());
				}else
				{
					listenerLoopExecuteMethod();
				}
				
				if(PROCESS_SHOULD_TERMINATE)
					break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    TYPES = Growl::notificationTypes.size();
                    PROCESS_SHOULD_TERMINATE = Growl::PROCESS_SHOULD_TERMINATE;
                }
			}
			
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                Growl::PROCESS_SHOULD_RESUME = false;
            }

		}else
		{
			PA_PutProcessToSleep(PA_GetCurrentProcessNumber(), CALLBACK_SLEEP_TIME);
		}
	
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = Growl::PROCESS_SHOULD_TERMINATE;
        }
        
		if(PROCESS_SHOULD_TERMINATE)
			break;
	}
	
	/* need to detach delegate in order to release it */	
	[GrowlApplicationBridge setGrowlDelegate:nil];
	
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        Growl::notificationTypes.clear();
        Growl::notificationContexts.clear();
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        Growl::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);

        Growl::METHOD_PROCESS_ID = 0;
    }

    [Growl::listener release];
    
	PA_KillProcess();
}

void listenerLoopStart()
{
	if(!Growl::METHOD_PROCESS_ID)
	{
        std::lock_guard<std::mutex> lock(globalMutex1);
        
		Growl::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
																						 Growl::MONITOR_PROCESS_STACK_SIZE,
																						 Growl::MONITOR_PROCESS_NAME);
	}
}

void listenerLoopFinish()
{
	if(Growl::METHOD_PROCESS_ID)
	{
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            Growl::PROCESS_SHOULD_TERMINATE = true;
        }
		
		PA_YieldAbsolute();
		
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);
         
            Growl::PROCESS_SHOULD_RESUME = true;
        }
	}
}

void listenerLoopExecute()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);

        Growl::PROCESS_SHOULD_TERMINATE = false;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);

        Growl::PROCESS_SHOULD_RESUME = true;
    }
}

void listenerLoopExecuteMethod()
{
    CUTF16String clickContext;
    notification_type_t type;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        std::vector<notification_type_t>::iterator t = Growl::notificationTypes.begin();
        std::vector<CUTF16String>::iterator c = Growl::notificationContexts.begin();
        
        notification_type_t type = *t;
        CUTF16String clickContext = *c;
        
        Growl::notificationTypes.erase(t);
        Growl::notificationContexts.erase(c);
    }
    
	method_id_t methodId = PA_GetMethodID((PA_Unichar *)Growl::LISTENER_METHOD.getUTF16StringPtr());
																		
	if(methodId)
	{
		PA_Variable	params[2];
		params[0] = PA_CreateVariable(eVK_Longint);
		params[1] = PA_CreateVariable(eVK_Unistring);
		
		PA_SetLongintVariable(&params[0], type);
		PA_Unistring context = PA_CreateUnistring((PA_Unichar *)clickContext.c_str());
		PA_SetStringVariable(&params[1], &context);
		
		PA_ExecuteMethodByID(methodId, params, 2);
		
		PA_ClearVariable(&params[0]);
		PA_ClearVariable(&params[1]);
        
	}else{

		PA_Variable	params[3];
		params[1] = PA_CreateVariable(eVK_Longint);
		params[2] = PA_CreateVariable(eVK_Unistring);
		
		PA_SetLongintVariable(&params[1], type);
		PA_Unistring context = PA_CreateUnistring((PA_Unichar *)clickContext.c_str());
		PA_SetStringVariable(&params[2], &context);
		
		params[0] = PA_CreateVariable(eVK_Unistring);
		PA_Unistring method = PA_CreateUnistring((PA_Unichar *)Growl::LISTENER_METHOD.getUTF16StringPtr());
		PA_SetStringVariable(&params[0], &method);
		
		/* execute method */
		PA_ExecuteCommandByID(1007, params, 3);
		
		PA_ClearVariable(&params[0]);
		PA_ClearVariable(&params[1]);
		PA_ClearVariable(&params[2]);
	}
}

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{

}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		listenerLoopFinish();
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
// --- Growl

		case 1 :
			Growl_Set_notification_method(pResult, pParams);
			break;

		case 2 :
			Growl_SET_MIST_ENABLED(pResult, pParams);
			break;

		case 3 :
			Growl_Get_mist_enabled(pResult, pParams);
			break;

		case 4 :
			Growl_POST_NOTIFICATION(pResult, pParams);
			break;

		case 5 :
			Growl_Get_notification_method(pResult, pParams);
			break;

	}
}

// ------------------------------------- Growl ------------------------------------

#pragma mark -

void Growl_POST_NOTIFICATION(sLONG_PTR *pResult, PackagePtr pParams)
{
	if(!IsProcessOnExit())
	{
		C_TEXT Param1;
		C_TEXT Param2;
		C_LONGINT Param4;
		C_LONGINT Param5;
		C_TEXT Param6;
		C_TEXT Param7;
		
		Param1.fromParamAtIndex(pParams, 1);//title
		Param2.fromParamAtIndex(pParams, 2);//description
		//icon is managed directly
		Param4.fromParamAtIndex(pParams, 4);//priority (-2 to +2)
		Param5.fromParamAtIndex(pParams, 5);//sticky
		Param6.fromParamAtIndex(pParams, 6);//click-context
		Param7.fromParamAtIndex(pParams, 7);//identifier
		
		NSString *title = Param1.copyUTF16String();
		NSString *description = Param2.copyUTF16String();
		signed int priority = Param4.getIntValue();
		priority = (priority < -2) ? -2 :priority; //-2 to +2
		priority = (priority >  2) ?  2 :priority; //-2 to +2
		BOOL isSticky = (BOOL)Param5.getIntValue();
		NSString *clickContext = Param6.copyUTF16String();
		NSString *identifier = Param7.copyUTF16String();
		
		listenerLoopStart();
		
		@autoreleasepool
		{
			//icon
			PA_Picture p = *(PA_Picture *)(pParams[2]);
			CGImageRef cgImage = (CGImageRef)PA_CreateNativePictureForScreen(p);
			NSData *iconData = nil;
			
			if(cgImage)
			{
				NSImage *image = [[NSImage alloc]initWithCGImage:cgImage size:NSZeroSize];
				CFRelease(cgImage);
				iconData = [image TIFFRepresentation];
				[image release];
			}
			
			[GrowlApplicationBridge notifyWithTitle:title
																	description:description
														 notificationName:Growl::defaultNotificationName
																		 iconData:iconData
																		 priority:priority
																		 isSticky:isSticky
																 clickContext:clickContext
																	 identifier:[identifier length] == 0 ? nil : identifier];
		}
		
		//cleanup
		[title release];
		[description release];
		[clickContext release];
		[identifier release];
		
	}
	
}

#pragma mark -

void Growl_Get_notification_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	Growl::LISTENER_METHOD.setReturn(pResult);
}

void Growl_Set_notification_method(sLONG_PTR *pResult, PackagePtr pParams)
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        Growl::LISTENER_METHOD.fromParamAtIndex(pParams, 1);
    }
}

void Growl_SET_MIST_ENABLED(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	[GrowlApplicationBridge setShouldUseBuiltInNotifications:Param1.getIntValue()];
}

void Growl_Get_mist_enabled(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT returnValue;
	
	returnValue.setIntValue([GrowlApplicationBridge shouldUseBuiltInNotifications]);
	
	returnValue.setReturn(pResult);
}
